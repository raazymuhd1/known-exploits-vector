// SPDX-Licenses-Identifier: MIT;
pragma solidity 0.8.20;

import { Test, console } from "forge-std/Test.sol";
import { StdInvariant } from "forge-std/StdInvariant.sol";
import { HandlerStatefulFuzzCatches } from "../../../src/invariant-break/HandlerStatefulFuzzCatches.sol";
import { MockUSDC } from "../../mocks/MockUSDC.sol";
import { YeildERC20 } from "../../mocks/YeildERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract AttemptedBreakTest is StdInvariant, Test {
    HandlerStatefulFuzzCatches handlerStatefulFuzzCatches;
    YeildERC20 yieldErc20;
    MockUSDC mockUsdc;
    IERC20[] supportedTokens;

    address user = makeAddr("USER");
    uint256 startingAmount;

    function setUp() public {
        vm.startPrank(user);
        yieldErc20 = new YeildERC20();
        mockUsdc = new MockUSDC();
        startingAmount = yieldErc20.INITIAL_SUPPLY();
        mockUsdc.mint(user,startingAmount);
        vm.stopPrank();

        supportedTokens.push(yieldErc20);
        supportedTokens.push(mockUsdc);

        handlerStatefulFuzzCatches = new HandlerStatefulFuzzCatches(supportedTokens);
    }

    function testStartingBalanceTheSame() public {
        assert(startingAmount == yieldErc20.balanceOf(user));
        assert(startingAmount == mockUsdc.balanceOf(user));

        console.log(startingAmount);
        console.log(yieldErc20.balanceOf(user));
    }

    function statefulFuzz_testInvariantBreaks() public {
        vm.startPrank(user);
        handlerStatefulFuzzCatches.withdrawToken(yieldErc20);
        handlerStatefulFuzzCatches.withdrawToken(mockUsdc);
        vm.stopPrank();

        assert(mockUsdc.balanceOf(address(handlerStatefulFuzzCatches)) == 0);
        assert(yieldErc20.balanceOf(address(handlerStatefulFuzzCatches)) == 0);

        assert(mockUsdc.balanceOf(user) == startingAmount);
        assert(yieldErc20.balanceOf(user) == startingAmount);

    }

}